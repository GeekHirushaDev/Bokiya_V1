/**
 B O K I Y A - #v1

🔗 Dev: https://wa.me/94755681782 (@Bokiya_Developers)
🔗 Team: GH Deve🚀opers

📜 GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007

📌 Permission & Copyright:
If you're using any of these codes, please ask for permission or mention https://github.com/GeekHirushaDev/Bokiya_V1 in your repository.

⚠️ Warning:
- This bot is not an officially certified WhatsApp bot.
- Report any bugs or glitches to the developer.
- Seek permission from the developer to use any of these codes.
- This bot does not store user's personal data.
- Certain files in this project are private and not publicly available for edit/read (encrypted).
- The repository does not contain any misleading content.
- The developer has not copied code from repositories they don't own. If you find matching code, please contact the developer.

Contact: alammdarif07@gmail.com (for reporting bugs & permission)
          https://wa.me/94755681782 (to contact on WhatsApp)

🚀 Thank you for using Bokiya v1! 🚀
**/

exports.cmdName = () => ({
  name: ['fullpic'],
  alias: ['fulpic','fullpicture'],
  category: "imgmaker",
  desc: "Convert any image ratio into 1:1 with white background."
});

/**
 * ⚠️ Strictly under copyright by @Bokiya_Developers
 **/
exports.getCommand = async (BokiyaDev, pika, prefix, command) => {
  const Config = require("../../config");
  const quoted = pika.quoted ? pika.quoted : pika;
  const mime = (quoted.msg || quoted).mimetype || "";
  if (!/image/.test(mime)) return pika.reply(`Please tag an image or send an image with caption *${prefix + command}*`);
  await pika.react("🤍");
  const util = require('util');
  const exec = util.promisify(require('child_process').exec);
  const fs = require('fs').promises;
  const path = require('path');
  const Jimp = require('jimp');
  const proceed = await BokiyaDev.sendMessage(pika.chat, { text: Config.message.wait }, { quoted: pika });
  const image = await quoted.download(await getRandomName(4));
  const mName = await getRandomName(5) + '.jpg';
  const pathOut = path.join(__dirname, '..', 'database', 'trash', mName);
 
  async function makeMedia(mediaBuffer, mName) {
  try {
    const image = await Jimp.read(mediaBuffer);
    if (image.getWidth() === image.getHeight()) return pika.edit("✅ This media is already in a square size.", proceed.key);
    const size = Math.max(image.getWidth(), image.getHeight());
    const squareImage = new Jimp(size, size, 0xFFFFFFFF);
    squareImage.composite(image, (size - image.getWidth()) / 2, (size - image.getHeight()) / 2);
    await squareImage.writeAsync(pathOut);
    pika.delete(proceed.key);
    return true;
  } catch (error) {
    pika.edit("❌ Can't proceed this media, please choose another.", proceed.key);
    return
  }
}

makeMedia(image, mName).then(async (result) => {
  if (result) {
    try {
      const media = await fs.readFile(pathOut);
      await BokiyaDev.sendMessage(pika.chat, {
        image: media,
        caption: `_© Generated by ${Config.botname}_`
      }, { quoted: pika });
      await fs.unlink(pathOut);
    } catch (error) {
      console.error('Error:', error);
    }
  }
});
};

async function getRandomName(length) {
  const alphabet = 'abcdefghijklmnopqrstuvwxyz';
  let name = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * alphabet.length);
    name += alphabet[randomIndex];
  }
  return name;
};
